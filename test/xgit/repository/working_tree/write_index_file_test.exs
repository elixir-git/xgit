defmodule Xgit.Repository.WorkingTree.WriteIndexFileTest do
  use Xgit.GitInitTestCase, async: true

  alias Xgit.Core.DirCache
  alias Xgit.Repository.WorkingTree.WriteIndexFile
  alias Xgit.Util.TrailingHashDevice

  import FolderDiff

  describe "to_iodevice/1" do
    test "happy path: matches empty index generated by command-line git", %{ref: ref, xgit: xgit} do
      # An initialized git repo doesn't have an index file at all.
      # Adding and removing a file generates an empty index file.

      {_output, 0} =
        System.cmd(
          "git",
          [
            "update-index",
            "--add",
            "--cacheinfo",
            "100644",
            "18832d35117ef2f013c4009f5b2128dfaeff354f",
            "hello.txt"
          ],
          cd: ref
        )

      {_output, 0} =
        System.cmd(
          "git",
          [
            "update-index",
            "--remove",
            "hello.txt"
          ],
          cd: ref
        )

      git_dir = Path.join(xgit, ".git")
      File.mkdir_p!(git_dir)

      index_path = Path.join(git_dir, "index")
      assert :ok = write_dir_cache_to_path(DirCache.empty(), index_path)

      assert_files_are_equal(Path.join([ref, ".git", "index"]), index_path)
    end

    test "happy path: can write an index file with two entries that matches command-line git", %{
      ref: ref,
      xgit: xgit
    } do
      {_output, 0} =
        System.cmd(
          "git",
          [
            "update-index",
            "--add",
            "--cacheinfo",
            "100644",
            "18832d35117ef2f013c4009f5b2128dfaeff354f",
            "hello.txt"
          ],
          cd: ref
        )

      {_output, 0} =
        System.cmd(
          "git",
          [
            "update-index",
            "--add",
            "--cacheinfo",
            "100644",
            "d670460b4b4aece5915caf5c68d12f560a9fe3e4",
            "test_content.txt"
          ],
          cd: ref
        )

      dir_cache = %DirCache{
        entries: [
          %DirCache.Entry{
            assume_valid?: false,
            ctime: 0,
            ctime_ns: 0,
            dev: 0,
            extended?: false,
            gid: 0,
            ino: 0,
            intent_to_add?: false,
            mode: 0o100644,
            mtime: 0,
            mtime_ns: 0,
            name: 'hello.txt',
            object_id: "18832d35117ef2f013c4009f5b2128dfaeff354f",
            size: 0,
            skip_worktree?: false,
            stage: 0,
            uid: 0
          },
          %DirCache.Entry{
            assume_valid?: false,
            ctime: 0,
            ctime_ns: 0,
            dev: 0,
            extended?: false,
            gid: 0,
            ino: 0,
            intent_to_add?: false,
            mode: 0o100644,
            mtime: 0,
            mtime_ns: 0,
            name: 'test_content.txt',
            object_id: "d670460b4b4aece5915caf5c68d12f560a9fe3e4",
            size: 0,
            skip_worktree?: false,
            stage: 0,
            uid: 0
          }
        ],
        entry_count: 2,
        version: 2
      }

      git_dir = Path.join(xgit, ".git")
      File.mkdir_p!(git_dir)

      index_path = Path.join(git_dir, "index")
      assert :ok = write_dir_cache_to_path(dir_cache, index_path)

      assert_files_are_equal(Path.join([ref, ".git", "index"]), index_path)
    end

    test "error: unsupported version", %{xgit: xgit} do
      dir_cache = %DirCache{version: 3, entry_count: 0, entries: []}

      git_dir = Path.join(xgit, ".git")
      File.mkdir_p!(git_dir)

      index_path = Path.join(git_dir, "index")
      assert {:error, :unsupported_version} = write_dir_cache_to_path(dir_cache, index_path)
    end

    test "error: invalid", %{xgit: xgit} do
      dir_cache = %DirCache{version: 2, entry_count: 1, entries: []}

      git_dir = Path.join(xgit, ".git")
      File.mkdir_p!(git_dir)

      index_path = Path.join(git_dir, "index")
      assert {:error, :invalid_dir_cache} = write_dir_cache_to_path(dir_cache, index_path)
    end
  end

  defp write_dir_cache_to_path(dir_cache, path) do
    with {:ok, iodevice} <- TrailingHashDevice.open_file_for_write(path),
         :ok <- WriteIndexFile.to_iodevice(dir_cache, iodevice) do
      File.close(iodevice)
    else
      {:error, reason} -> {:error, reason}
    end
  end
end
